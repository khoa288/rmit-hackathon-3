<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mic + Laughter Scorer (MediaPipe YAMNet, robust)</title>
<style>
  :root { --fg:#0f172a; --muted:#6b7280; --ok:#16a34a; --bad:#ef4444; --warn:#eab308; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 2rem; color: var(--fg); }
  .row { display:flex; gap:.75rem; align-items:center; flex-wrap:wrap; }
  button{ padding:.7rem 1rem; font-size:1rem; border-radius:.75rem; border:1px solid #cbd5e1; background:#f8fafc; cursor:pointer }
  button.primary{ background:#111827; color:#fff; border-color:#111827 }
  .mono{ font-variant-numeric: tabular-nums; font-feature-settings:"tnum"; }
  .ok{ color:var(--ok) } .bad{ color:var(--bad) } .warn{ color:var(--warn) } .muted{ color:var(--muted) }
  .bar{ height:14px; background:#e5e7eb; border-radius:999px; overflow:hidden; width:380px; max-width:100% }
  .fill{ height:100%; width:0%; background:linear-gradient(90deg,#93c5fd,#2563eb); transition:width .12s linear }
  .fill.green{ background:linear-gradient(90deg,#86efac,#16a34a) }
  .fill.yellow{ background:linear-gradient(90deg,#fde68a,#f59e0b) }
  pre{ background:#0b1220; color:#e5e7eb; padding:.75rem 1rem; border-radius:.5rem; overflow:auto; max-height:240px }
</style>

<h1>Microphone + Laughter Scorer</h1>
<p class="muted">Enable mic → we compute RMS and a <b>Laughter %</b> on-device using MediaPipe’s YAMNet. HappyScore = EMA(Laughter) × 100.</p>

<div class="row">
  <button id="enable" class="primary">Enable Microphone</button>
  <button id="stop" disabled>Stop</button>
  <span id="status">Idle.</span>
</div>

<p>
  Secure context: <b id="secure" class="mono"></b> ·
  Origin: <span id="origin" class="mono"></span> ·
  Permission (if supported): <b id="perm" class="mono">n/a</b>
</p>

<div class="row" style="margin:.5rem 0 1rem">
  <div class="bar"><div id="rmsBar" class="fill"></div></div>
  <span class="mono" id="rmsTxt">RMS 0.000</span>
</div>

<div class="row" style="margin:.25rem 0 1rem">
  <div class="bar" title="Laughter probability"><div id="laughBar" class="fill green"></div></div>
  <span class="mono" id="laughTxt">Laughter 0.0%</span>
</div>

<div class="row" style="margin:.25rem 0 1.25rem">
  <div class="bar" title="HappyScore (EMA of Laughter × 100)"><div id="happyBar" class="fill yellow"></div></div>
  <span class="mono" id="happyTxt">HappyScore 0</span>
</div>

<p class="muted">10s running average (sanity): <span class="mono" id="avg10">0.0%</span></p>

<h3>Debug (top-5 classes each second)</h3>
<pre id="log" class="mono"></pre>

<script type="module">
const $ = s => document.querySelector(s);
const log = m => ($('#log').textContent += m + "\n");
const isSecure = () => window.isSecureContext || location.protocol === "https:" ||
                       location.hostname === "localhost" || location.hostname === "127.0.0.1";

$("#origin").textContent = location.origin;
$("#secure").textContent = isSecure();
$("#secure").className = isSecure() ? "ok" : "bad";

(async () => {
  try {
    const p = await navigator.permissions?.query?.({ name: "microphone" });
    if (p) {
      const apply = () => { $("#perm").textContent = p.state; $("#perm").className = (p.state==="granted")?"ok":(p.state==="denied")?"bad":"warn"; };
      apply(); p.onchange = apply;
    } else { $("#perm").textContent = "unsupported"; $("#perm").className = "muted"; }
  } catch { $("#perm").textContent = "error"; $("#perm").className = "muted"; }
})();

/* ===== CDN + model URLs (version-pinned, with fallbacks) ===== */
const JSDELIVR = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-audio@0.10.20";
const UNPKG    = "https://unpkg.com/@mediapipe/tasks-audio@0.10.20";
const WASM_DIR = "/wasm";
const MODEL_PRIMARY  = "https://tfhub.dev/google/lite-model/yamnet/classification/tflite/1?lite-format=tflite";
const MODEL_FALLBACK = "https://storage.googleapis.com/mediapipe-models/audio_classifier/yamnet/float32/1/yamnet.tflite";

/* ===== Globals ===== */
let ctx, analyser, meterBuf, raf, procNode;
let ring, ridx = 0, need = 0;
let audioClassifier = null, running = false;
const EMA_ALPHA = 0.2;
let ema = 0, avgSum = 0, avgCount = 0;

/* Robust laughter matcher (case-insensitive substrings) */
function isLaugh(name) {
  const n = name.toLowerCase();
  return n.includes("laugh") || n.includes("giggl") || n.includes("chuckle") ||
         n.includes("chortle") || n.includes("snicker");
}

/* ---- import tasks-audio with fallback ---- */
async function importTasksAudio() {
  try {
    log("Loading @mediapipe/tasks-audio from jsDelivr…");
    return await import(JSDELIVR);
  } catch (e) {
    log("jsDelivr failed → falling back to unpkg…");
    return await import(UNPKG);
  }
}

/* ---- create classifier (AUDIO_CLIPS mode) ---- */
async function createClassifier() {
  const { FilesetResolver, AudioClassifier } = await importTasksAudio();
  let fileset;
  try { fileset = await FilesetResolver.forAudioTasks(JSDELIVR + WASM_DIR); }
  catch { fileset = await FilesetResolver.forAudioTasks(UNPKG + WASM_DIR); }

  try {
    audioClassifier = await AudioClassifier.createFromOptions(fileset, {
      baseOptions: { modelAssetPath: MODEL_PRIMARY },
      runningMode: "AUDIO_CLIPS"
    });
    log("Model loaded from tfhub.");
  } catch {
    audioClassifier = await AudioClassifier.createFromOptions(fileset, {
      baseOptions: { modelAssetPath: MODEL_FALLBACK },
      runningMode: "AUDIO_CLIPS"
    });
    log("Model loaded from Google Cloud Storage.");
  }
}

/* ---- meters ---- */
function startRmsMeter(source) {
  analyser = ctx.createAnalyser(); analyser.fftSize = 1024;
  meterBuf = new Float32Array(analyser.fftSize);
  source.connect(analyser);
  (function tick(){
    analyser.getFloatTimeDomainData(meterBuf);
    let s=0; for (let i=0;i<meterBuf.length;i++) s+=meterBuf[i]*meterBuf[i];
    const rms = Math.sqrt(s/meterBuf.length);
    $("#rmsTxt").textContent = "RMS " + rms.toFixed(3);
    $("#rmsBar").style.width = Math.min(100, rms*200) + "%";
    raf = requestAnimationFrame(tick);
  })();
}

/* ---- run classify every ~1 s on a 1 s window (YAMNet operates ≈0.975 s) ---- */
function setupStreamClassification(stream) {
  ring = new Float32Array(16000); ridx = 0; need = ring.length;

  const source = ctx.createMediaStreamSource(stream);
  // ScriptProcessorNode is deprecated but widely supported; fine for this test.
  procNode = ctx.createScriptProcessor(16384, 1, 1);
  source.connect(procNode); procNode.connect(ctx.destination);
  startRmsMeter(source);

  procNode.onaudioprocess = () => {
    if (!running) return;
    const x = event.inputBuffer.getChannelData(0);
    for (let i=0;i<x.length;i++){ ring[ridx++] = x[i]; if (ridx===ring.length) ridx=0; }
    need -= x.length;
    if (need <= 0) {
      need = ring.length;

      // Assemble 1 s slice from the ring
      const out = new Float32Array(ring.length);
      const tail = ring.length - ridx;
      out.set(ring.subarray(ridx), 0);
      out.set(ring.subarray(0, ridx), tail);

      // Synchronous classify per docs: classify(Float32Array, sampleRate?) → results[]
      // API: https://ai.google.dev/edge/api/mediapipe/js/tasks-audio.audioclassifier
      let results = [];
      try { results = audioClassifier.classify(out, ctx.sampleRate); } catch (e) {
        log("classify() error: " + (e?.message || e));
        return;
      }
      const cats = results?.[0]?.classifications?.[0]?.categories || [];

      // Top-5 debug
      const top5 = [...cats].sort((a,b)=>(b.score||0)-(a.score||0)).slice(0,5)
        .map(c => `${(c.score*100).toFixed(1)}% ${c.categoryName}`).join(" | ");
      log(top5 || "(no categories)");

      // Laughter probability (sum of matching labels)
      let pLaugh = 0;
      for (const c of cats) if (c?.categoryName && isLaugh(c.categoryName)) pLaugh += c.score || 0;

      // Update UI (EMA smoothing on %)
      const pct = Math.max(0, Math.min(1, pLaugh));
      $("#laughTxt").textContent = "Laughter " + (pct*100).toFixed(1) + "%";
      $("#laughBar").style.width = (pct*100).toFixed(1) + "%";
      ema = EMA_ALPHA*(pct*100) + (1-EMA_ALPHA)*ema;
      $("#happyTxt").textContent = "HappyScore " + Math.round(ema);
      $("#happyBar").style.width = Math.min(100, ema) + "%";

      avgSum += pct; avgCount++;
      if (avgCount >= 10) { $("#avg10").textContent = ((avgSum/avgCount)*100).toFixed(1) + "%"; avgSum=0; avgCount=0; }
    }
  };
}

/* ---- buttons ---- */
$("#enable").onclick = async () => {
  $("#status").textContent = "Preparing…"; $("#status").className = ""; $("#log").textContent = "";
  if (!isSecure()) { $("#status").textContent = "Use HTTPS or http://localhost."; $("#status").className="bad"; alert("Needs HTTPS or http://localhost."); return; }

  try {
    if (!audioClassifier) await createClassifier();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const AC = window.AudioContext || window.webkitAudioContext;
    ctx = new AC({ sampleRate: 16000 });
    if (ctx.state === "suspended") await ctx.resume();

    const track = stream.getAudioTracks()[0];
    log("Got stream: " + JSON.stringify(track.getSettings()));
    log("AudioContext sampleRate: " + ctx.sampleRate);

    setupStreamClassification(stream);
    running = true;
    $("#enable").disabled = true; $("#stop").disabled = false;
    $("#status").textContent = "Mic active & model ready."; $("#status").className = "ok";
  } catch (e) {
    console.error(e);
    let msg = "Could not start.";
    if (e.name === "NotAllowedError" || e.name === "SecurityError") { msg = "Permission denied. Allow mic, then reload."; $("#status").className="bad"; }
    else if (e.name === "NotFoundError") { msg="No microphone found."; $("#status").className="bad"; }
    else { $("#status").className="warn"; }
    $("#status").textContent = msg; alert(msg);
    log(e.name + ": " + (e.message || ""));
  }
};

$("#stop").onclick = () => {
  running = false;
  try { procNode && procNode.disconnect(); } catch {}
  try { analyser && analyser.disconnect(); } catch {}
  cancelAnimationFrame(0);
  try { ctx && ctx.close(); } catch {}
  $("#enable").disabled = false; $("#stop").disabled = true;
  $("#status").textContent = "Stopped."; $("#status").className = "";
};
</script>
</html>
